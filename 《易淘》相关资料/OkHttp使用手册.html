<!DOCTYPE html>
<html>
<head>
<title>OkHttp使用手册</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>OkHttp使用手册</h1>
<h2>简介</h2>
<p>OkHttp是Square出的Http通讯库，支持HTTP和HTTP/2，用于Android应用和Java应用。</p>
<p>OkHttp是非常优秀的Http通讯库，将Http连接中各种繁杂的问题，对并发的支持，对常见异常的处理等封装在底层，提供简单易用的API供应用中调用。与之相比，HttpUrlConnection的使用过于复杂，Appache的HttpClient在Android平台上的运行又有各种问题，在Android 6.0之后，已经将HttpClient库从SDK中删除，全面转向使用OkHttp。</p>
<p>目前有很多知名的Android三方框架都使用OkHttp作为网络连接的默认基栈，例如Volley，Glide，Retrofit等，从中也能看出学习OkHttp的必要性。</p>
<h2>基本使用</h2>
<h3>在项目中添加对OkHttp的依赖</h3>
<p>在需要使用OkHttp的模块的build.gradle文件中，添加如下依赖：(版本号可能变更)</p>
<pre><code>compile 'com.squareup.okhttp3:okhttp:3.2.0'
</code></pre>

<h3>初始化</h3>
<p>OkHttp框架的核心类是OkHttpClient，此类可直接实例化。由于OkHttpClient内部处理了并发，多线程和Socket重用等问题，为了节省资源，整个应用中使用一个OkHttpClient对象即可，可以对它做Singleton封装。</p>
<pre><code>OkHttpClient okHttpClient = new OkHttpClient();
</code></pre>

<h3>OkHttp请求的构建</h3>
<p>代表Http请求的类是Request，该类使用构造器模式，最简单的构造GET请求如下：</p>
<pre><code>Request request = new Request.Builder()
      .url(url)
      .build();
</code></pre>

<p>要构造Post请求，在构建Request时增加请求体即可：</p>
<pre><code>Request request = new Request.Builder()
    .url(url)
    .post(RequestBody)
    .build();

RequestBody formBody = new FormEncodingBuilder()
    .add(&quot;name&quot;, &quot;Cuber&quot;)
    .add(&quot;age&quot;, &quot;26&quot;)
    .build();
</code></pre>

<h3>OkHttp请求的发送</h3>
<p>请求的发送有两种形式，一种是直接同步执行，阻塞调用线程，直接返回结果；另一种是通过队列异步执行，不阻塞调用线程，通过回调方法返回结果。如下所示：</p>
<p>同步执行：</p>
<pre><code>// 如果返回null，代表超时或没有网络连接
Response response = client.newCall(request).execute();
</code></pre>

<p>异步回调：</p>
<pre><code>Response response = client.newCall(request).enqueue(new Callback() {

    @Override
    public void onFailure(Request request, IOException e) {
        //超时或没有网络连接
        //注意：这里是后台线程！
    }

    @Override
        public void onResponse(Response response) throws IOException {
        //成功
        //注意：这里是后台线程！
    }
});
</code></pre>

<p>以上这些就是快速上手OkHttp需要知道的全部内容，可以从中看出，它的API非常简单易用。</p>
<h2>Call模型</h2>
<p>Http客户端的任务是处理请求和响应，这说起来简单，但实际过程很复杂。</p>
<ul>
<li>请求：Http请求包含一个URL，请求方法(例如GET或者POST)，请求头。还可能包含请求体，可以是数据流也可以是指定的内容类别。</li>
<li>响应：用一个响应码来回应请求(例如200代表成功，404代表页面未找到)，响应头和响应体。</li>
</ul>
<h3>请求的重写</h3>
<ul>
<li>为了保证正确性和传输效率，OkHttp会在发送你的请求之前重写它，例如：</li>
<li>OkHttp可能会添加原始请求中缺失的头信息，包括Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type。</li>
<li>为了实现透明的响应压缩(transparent response compression)，OkHttp会增加Accept-Encoding头信息。</li>
<li>如果你收到了cookie，OkHttp会增加Cookie头信息。</li>
<li>某些请求可能会对响应做缓存。如果被缓存的响应不是最新的，OkHttp能做一个有条件的GET请求来下载更新后的响应。此功能需要添加If-Modified-Since和If-None-Match等头信息。</li>
</ul>
<h3>响应的重写</h3>
<p>如果使用了透明压缩，OkHttp会去掉对应响应的Content-Encoding和Content-Length头信息，因为它们不能应用于解压后的响应体。</p>
<p>如果有条件的GET成功了，网络侧的响应和缓存的响应会被自动合并。</p>
<h3>重定向</h3>
<p>如果你请求的URL被移动了，服务器会返回类似于302这样的响应码，来指明新的URL。OkHttp能跟随新的URL，获取到最终的响应。</p>
<h3>请求的重试</h3>
<p>有时会发生连接失败：可能网络连接状况不好，或者服务器不可达。OkHttp会自动使用不同的路由来重试请求。</p>
<h3>Call模型</h3>
<p>由于以上的重写，重定向和重试等操作，你的一个简单请求可能会产生多个请求和响应。OkHttp使用Call这一概念对此来建模：不论为了满足你的请求任务，中间做了多少次请求和响应，都算作一个Call。</p>
<p>Call有两种方式来执行：</p>
<ul>
<li>同步方式：你的线程会被阻塞，知道响应可读。</li>
<li>异步方式：你在任意线程将请求排队，当响应可读时，会在另一个线程拿到回调。</li>
</ul>
<h3>Call的取消</h3>
<p>使用Call.cancel()来停止一个执行中的请求。如果线程正在写请求或读响应，则会收到IOException。使用此方法，在一个Call已经不需要时取消它，可以节省网络流量</p>
<p>Call可以在任意线程取消，如果请求没有完成，调用取消方法会导致请求失败，读写请求体和响应体的代码会产生IOException。</p>
<h2>拦截器</h2>
<p>OkHttp在请求响应过程中可以添加拦截器，拦截请求和响应的数据等。</p>
<h3>需要加依赖</h3>
<pre><code>compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'
</code></pre>

<h3>用法</h3>
<p>初始化拦截器，设置拦截级别，添加到OkHttpClient中</p>
<pre><code>HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);

okHttpClient = new OkHttpClient.Builder()
        .addInterceptor(interceptor)
        .build();
</code></pre>

<h2>响应体解析-使用Gson</h2>
<h3>添加依赖</h3>
<pre><code>compile 'com.google.code.gson:gson:2.8.0'
</code></pre>

<p>以下代码使用Gson库来解析服务器响应的JSON信息</p>
<h2>FAQ</h2>
<h3>OkHttp如何设置超时？</h3>
<p>设置超时的方法很简单：</p>
<pre><code>OkHttpClient client = new OkHttpClient.Builder()
    .connectTimeout(10, TimeUnit.SECONDS)  // 连接超时
    .writeTimeout(10, TimeUnit.SECONDS)    // Socket写超时
    .readTimeout(30, TimeUnit.SECONDS)     // Socket读超时
    .build();
</code></pre>

<p>注意readTimeout和writeTimeout被用于OkHttp内部的Connection类，用在setSoTimeout方法上来设置Socket。</p>
<p>另外，在2.5.0版本之后，读、写、连接超时的默认值是10s。</p>
<h3>OkHttp中，Callback的回调方法onFailure和onResponse是在主线程执行码？</h3>
<p>不是，OkHttp是一个Java库，不是Android库，它对Android主线程一无所知，所以这两个回调方法自然是在后台线程执行。实际开发中，常常对OkHttp做二次封装，来直接将结果传递给主线程。</p>
<p>也可以实现Callback类，自己做一个抽象类UICallback，从而可以在UI中运行</p>
<pre><code>public abstract class UICallback implements Callback{

    private final Handler handler = new Handler(Looper.getMainLooper());

    @Override
    public void onFailure(final Call call, final IOException e) {
        handler.post(new Runnable() {
            @Override
            public void run() {
                onFailureInUi(call, e);
            }
        });
    }

    @Override
    public void onResponse(final Call call, final Response response)  {

        try {
            if (!response.isSuccessful()) {
                throw new IOException(&quot;error code: &quot; + response.code());
            }

            final String content = response.body().string();
            handler.post(new Runnable() {
                @Override
                public void run() {
                    onResponseInUi(call, content);
                }
            });
        } catch (IOException e) {
            onFailure(call, e);
        }
    }

    public abstract void onFailureInUi(Call call, IOException e);

    public abstract void onResponseInUi(Call call, String body);
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
